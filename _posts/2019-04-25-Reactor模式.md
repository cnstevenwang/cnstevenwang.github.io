> 引用自 https://www.jianshu.com/p/eef7ebe28673

<div data-note-content="" class="show-content">
          <div class="show-content-free">
            <p>在处理web请求时，通常有两种体系结构，分别为：thread-based architecture（基于线程）、event-driven architecture（事件驱动）</p><h2>thread-based&nbsp;architecture</h2><p>基于线程的体系结构通常会使用多线程来处理客户端的请求，每当接收到一个请求，便开启一个独立的线程来处理。这种方式虽然是直观的，但是仅适用于并发访问量不大的场景，因为线程需要占用一定的内存资源，且操作系统在线程之间的切换也需要一定的开销，当线程数过多时显然会降低web服务器的性能。并且，当线程在处理I/O操作，在等待输入的这段时间线程处于空闲的状态，同样也会造成cpu资源的浪费。一个典型的设计如下：</p><div class="image-package">
<div class="image-container" style="max-width: 661px; max-height: 292px; background-color: transparent;">
<div class="image-container-fill" style="padding-bottom: 44.18%;"></div>
<div class="image-view" data-width="661" data-height="292"><img data-original-src="//upload-images.jianshu.io/upload_images/10345180-faaebf9335592620.png" data-original-width="661" data-original-height="292" data-original-format="image/png" data-original-filesize="56371" style="cursor: zoom-in;" class="" src="//upload-images.jianshu.io/upload_images/10345180-faaebf9335592620.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/661/format/webp"></div>
</div>
<div class="image-caption">

thread-based</div>
</div><h3>event-driven&nbsp;architecture</h3><p>事件驱动体系结构是目前比较广泛使用的一种。这种方式会定义一系列的事件处理器来响应事件的发生，并且将服务端接受连接与对事件的处理分离。其中，事件是一种状态的改变。比如，tcp中socket的new incoming connection、ready for read、ready for write。</p><h3>reactor</h3><p>reactor设计模式是event-driven&nbsp;architecture的一种实现方式，处理多个客户端并发的向服务端请求服务的场景。每种服务在服务端可能由多个方法组成。reactor会解耦并发请求的服务并分发给对应的事件处理器来处理。目前，许多流行的开源框架都用到了reactor模式，如：netty、node.js等，包括java的nio。</p><p>总体图示如下：</p><div class="image-package">
<div class="image-container" style="max-width: 640px; max-height: 292px; background-color: transparent;">
<div class="image-container-fill" style="padding-bottom: 45.629999999999995%;"></div>
<div class="image-view" data-width="640" data-height="292"><img data-original-src="//upload-images.jianshu.io/upload_images/10345180-fdaf4d307916cd8f.png" data-original-width="640" data-original-height="292" data-original-format="image/png" data-original-filesize="58932" style="cursor: zoom-in;" class="" src="//upload-images.jianshu.io/upload_images/10345180-fdaf4d307916cd8f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640/format/webp"></div>
</div>
<div class="image-caption">reactor</div>
</div><p>reactor主要由以下几个角色构成：handle、Synchronous Event Demultiplexer、Initiation Dispatcher、Event Handler、Concrete Event Handler</p><h4>Handle</h4><p>handle在linux中一般称为文件描述符，而在window称为句柄，两者的含义一样。handle是事件的发源地。比如一个网络socket、磁盘文件等。而发生在handle上的事件可以有connection、ready for read、ready for write等。</p><h4>Synchronous Event Demultiplexer</h4><p>同步事件分离器，本质上是系统调用。比如linux中的select、poll、epoll等。比如，select方法会一直阻塞直到handle上有事件发生时才会返回。</p><h4>Event Handler</h4><p>事件处理器，其会定义一些回调方法或者称为钩子函数，当handle上有事件发生时，回调方法便会执行，一种事件处理机制。</p><h4>Concrete Event Handler</h4><p>具体的事件处理器，实现了Event Handler。在回调方法中会实现具体的业务逻辑。</p><h4>Initiation Dispatcher</h4><p>初始分发器，也是reactor角色，提供了注册、删除与转发event handler的方法。当Synchronous Event Demultiplexer检测到handle上有事件发生时，便会通知initiation dispatcher调用特定的event handler的回调方法。</p><h4>处理流程</h4><p>1. 当应用向Initiation Dispatcher注册Concrete Event Handler时，应用会标识出该事件处理器希望Initiation Dispatcher在某种类型的事件发生发生时向其通知，事件与handle关联</p><p>2.&nbsp;Initiation Dispatcher要求注册在其上面的Concrete Event Handler传递内部关联的handle，该handle会向操作系统标识</p><p>3. 当所有的Concrete Event Handler都注册到&nbsp;Initiation Dispatcher上后，应用会调用handle_events方法来启动Initiation Dispatcher的事件循环，这时Initiation Dispatcher会将每个Concrete Event Handler关联的handle合并，并使用Synchronous Event Demultiplexer来等待这些handle上事件的发生</p><p>4. 当与某个事件源对应的handle变为ready时，Synchronous Event Demultiplexer便会通知&nbsp;Initiation Dispatcher。比如tcp的socket变为ready for reading</p><p>5.&nbsp;Initiation Dispatcher会触发事件处理器的回调方法。当事件发生时，&nbsp;Initiation Dispatcher会将被一个“key”（表示一个激活的handle）定位和分发给特定的Event Handler的回调方法</p><p>6.&nbsp;Initiation Dispatcher调用特定的Concrete Event Handler的回调方法来响应其关联的handle上发生的事件</p><h4>参考</h4><p>https://dzone.com/articles/understanding-reactor-pattern-thread-based-and-eve</p><p>Reactor &nbsp;“An Object Behavioral Pattern for Demultiplexing and Dispatching Handles for Synchronous Events“ &nbsp; &nbsp; Douglas C. Schmidt&nbsp;Department of Computer Science &nbsp;Washington University, St. Louis, MO</p>
          </div>
        </div>